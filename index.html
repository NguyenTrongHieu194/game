<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Flappy Bird - Fullscreen Mobile</title>
  <style>
    html,body {
      height:100%;
      margin:0;
      background:#70c5ce;
      -webkit-user-select: none;
      -ms-user-select: none;
      user-select: none;
      touch-action: manipulation; /* giảm scroll khi chạm */
    }
    #gameCanvas {
      display:block;
      width:100vw;
      height:100vh;
      background: linear-gradient(#87ceeb, #70c5ce);
      -webkit-tap-highlight-color: rgba(0,0,0,0);
    }
    /* Overlay nhỏ cho nút restart/info */
    .overlay {
      position:fixed;
      left:0;right:0;top:0;
      display:flex;align-items:center;justify-content:center;
      pointer-events:none;
    }
    .overlay .box {
      pointer-events:auto;
      background: rgba(0,0,0,0.45);
      color:#fff;padding:18px;border-radius:10px;text-align:center;
      font-family: sans-serif;
    }
    .sr-only { position:absolute; left:-9999px; }
  </style>
</head>
<body>
  <canvas id="gameCanvas" aria-label="Flappy Bird game"></canvas>
  <div class="overlay" id="overlay" style="display:none">
    <div class="box" id="overlayBox">...</div>
  </div>

<script>
/* ===== Flappy Bird - Fullscreen Mobile Ready =====
   - copy this file to index.html in repo root
   - supports touch/click/space
   - responsive full-screen canvas
*/

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Logical game size (use for consistent gameplay)
const LOG_W = 420, LOG_H = 640;

// Game state
let state = 'menu'; // 'menu','playing','dead'
let score = 0;
let best = Number(localStorage.getItem('flappy_best') || 0);

// Bird
const bird = { x: LOG_W * 0.27, y: LOG_H * 0.45, r: 14, vy: 0, rotation: 0 };

// Physics
const GRAVITY = 1200;
const FLAP_V = -320;
const MAX_DOWN_V = 700;

// Pipes
const pipes = [];
const PIPE_W = 62, GAP = 150, GROUND_H = 96;
let pipeTimer = 0, PIPE_INTERVAL = 1.4, PIPE_SPEED = 140;

// Timing & scaling
let lastTime = null;
let scale = 1;      // pixels to scale logical -> real
let dpr = 1;

// Audio (simple tones)
const audioCtx = (typeof AudioContext !== 'undefined') ? new AudioContext() : null;
function playTone(freq, duration=0.06, type='sine', vol=0.08){
  if(!audioCtx) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type; o.frequency.value = freq;
  g.gain.value = vol;
  o.connect(g); g.connect(audioCtx.destination);
  o.start(); o.stop(audioCtx.currentTime + duration);
}
function playFlap(){ playTone(700,0.07,'sawtooth',0.06); }
function playHit(){ playTone(120,0.18,'square',0.18); }
function playScore(){ playTone(1000,0.06); playTone(1300,0.06); }

// Resize canvas to full viewport and compute scale factor
function resizeCanvas(){
  const vw = Math.max(window.innerWidth, 320);
  const vh = Math.max(window.innerHeight, 480);
  // We keep LOG_W x LOG_H as logical coordinates and scale to fit viewport while covering area
  const ratio = Math.min(vw / LOG_W, vh / LOG_H);
  scale = ratio;
  // For crisp rendering use devicePixelRatio but cap it to 2 for perf
  dpr = Math.min(window.devicePixelRatio || 1, 2);
  canvas.style.width = vw + 'px';
  canvas.style.height = vh + 'px';
  canvas.width = Math.round(vw * dpr);
  canvas.height = Math.round(vh * dpr);
  // Set transform so logical coordinates map to scaled pixels
  ctx.setTransform(dpr * scale, 0, 0, dpr * scale, 0, 0);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Helpers
function randRange(a,b){ return a + Math.random() * (b - a); }

// Spawn pipe with min spacing relative to last pipe and viewport
function spawnPipe(){
  const minSpacing = Math.max(140, PIPE_SPEED * PIPE_INTERVAL * 0.9); // px logical
  let x = LOG_W + 20;
  if (pipes.length > 0){
    const last = pipes[pipes.length - 1];
    const desired = last.x + minSpacing;
    if (desired > x) x = desired;
  }
  const marginTop = 40, marginBottom = 80;
  const centerY = randRange(marginTop + GAP/2, LOG_H - GROUND_H - marginBottom - GAP/2);
  pipes.push({ x, gapY: centerY, passed: false });
}

// Reset
function reset(){
  score = 0;
  pipes.length = 0;
  pipeTimer = 0;
  bird.y = LOG_H * 0.45;
  bird.vy = 0;
  bird.rotation = 0;
  lastTime = null;
  // spawn a couple for visual starter
  for(let i=1;i<=2;i++){
    pipes.push({ x: LOG_W + i * 180, gapY: randRange(150, LOG_H - GROUND_H - 150), passed: false });
  }
  state = 'menu';
  showOverlay();
}

// Input (flap)
function flap(){
  // resume audio context on first gesture
  if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
  if(state === 'menu'){
    state = 'playing';
    bird.vy = FLAP_V; playFlap(); hideOverlay();
  } else if (state === 'playing'){
    bird.vy = FLAP_V; playFlap();
  } else if (state === 'dead'){
    reset();
  }
}

// Keyboard + mouse + touch
window.addEventListener('keydown', e => {
  if (e.code === 'Space') { e.preventDefault(); flap(); }
  if (e.code === 'KeyR' && state === 'dead') reset();
});
window.addEventListener('mousedown', e => { flap(); });
window.addEventListener('touchstart', e => { e.preventDefault(); flap(); }, { passive: false });

// Collision helper (circle vs rect)
function circleRectCollides(cx, cy, r, rx, ry, rw, rh){
  const closestX = Math.max(rx, Math.min(cx, rx + rw));
  const closestY = Math.max(ry, Math.min(cy, ry + rh));
  const dx = cx - closestX, dy = cy - closestY;
  return dx*dx + dy*dy < r*r;
}

function die(){
  if (state !== 'dead') { state = 'dead'; playHit(); showOverlay(true); }
}

// Update
function update(dt){
  if (state === 'playing'){
    bird.vy += GRAVITY * dt;
    if (bird.vy > MAX_DOWN_V) bird.vy = MAX_DOWN_V;
    bird.y += bird.vy * dt;
    bird.rotation = Math.max(-0.6, Math.min(1.2, bird.vy / 500));

    pipeTimer += dt;
    // process multiples if dt big
    while (pipeTimer >= PIPE_INTERVAL){
      pipeTimer -= PIPE_INTERVAL;
      spawnPipe();
    }

    // move pipes and scoring
    for (let i = pipes.length - 1; i >= 0; i--){
      const p = pipes[i];
      p.x -= PIPE_SPEED * dt;
      if (!p.passed && p.x + PIPE_W < bird.x - bird.r){
        p.passed = true; score++; playScore();
        if (score > best){ best = score; localStorage.setItem('flappy_best', best); }
      }
      if (p.x + PIPE_W < -50) pipes.splice(i, 1);
    }

    // collisions
    for (const p of pipes){
      const topRect = { x: p.x, y: 0, w: PIPE_W, h: p.gapY - GAP/2 };
      const botRect = { x: p.x, y: p.gapY + GAP/2, w: PIPE_W, h: LOG_H - GROUND_H - (p.gapY + GAP/2) };
      if (circleRectCollides(bird.x, bird.y, bird.r, topRect.x, topRect.y, topRect.w, topRect.h) ||
          circleRectCollides(bird.x, bird.y, bird.r, botRect.x, botRect.y, botRect.w, botRect.h)){
        die();
      }
    }

    // ground & ceiling
    if (bird.y + bird.r >= LOG_H - GROUND_H){ bird.y = LOG_H - GROUND_H - bird.r; die(); }
    if (bird.y - bird.r <= 0) bird.y = bird.r;
  }
}

// Draw
function drawBackground(){
  // sky + simple clouds
  ctx.fillStyle = '#70c5ce';
  ctx.fillRect(0,0,LOG_W,LOG_H);
  ctx.fillStyle = '#fff';
  for (let i=0;i<3;i++){
    ctx.beginPath();
    ctx.arc(80 + i*150, 80, 20, 0, Math.PI*2);
    ctx.arc(100 + i*150, 80, 30, 0, Math.PI*2);
    ctx.arc(130 + i*150, 80, 20, 0, Math.PI*2);
    ctx.fill();
  }
}
function draw(){
  // clear logical area
  ctx.clearRect(0,0,LOG_W,LOG_H);

  drawBackground();

  // pipes
  for (const p of pipes){
    ctx.fillStyle = '#2ea84f';
    const topH = p.gapY - GAP/2;
    ctx.fillRect(p.x, 0, PIPE_W, topH);
    ctx.fillRect(p.x, p.gapY + GAP/2, PIPE_W, LOG_H - GROUND_H - (p.gapY + GAP/2));
  }

  // ground
  ctx.fillStyle = '#d7b36a';
  ctx.fillRect(0, LOG_H - GROUND_H, LOG_W, GROUND_H);

  drawBird();

  // score
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 42px sans-serif';
  ctx.textAlign = 'center';
  if (state === 'playing' || state === 'dead') ctx.fillText(score, LOG_W/2, 84);

  // overlays
  if (state === 'menu'){
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    ctx.font = '28px sans-serif';
    ctx.fillText('Flappy Bird', LOG_W/2, 140);
    ctx.font = '16px sans-serif';
    ctx.fillText('Tap / Click / Space để nhảy', LOG_W/2, 180);
    ctx.font = '14px sans-serif';
    ctx.fillText('Best: ' + best, LOG_W/2, 210);
  } else if (state === 'dead'){
    // draw handled by overlay UI
  }
}

function drawBird(){
  // improved bird drawing (outline, wing anim)
  ctx.save();
  ctx.translate(bird.x, bird.y);
  ctx.rotate(bird.rotation);
  // body
  ctx.beginPath();
  ctx.fillStyle = '#ffeb3b';
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 2;
  ctx.arc(0,0,bird.r,0,Math.PI*2);
  ctx.fill(); ctx.stroke();
  // wing
  ctx.beginPath();
  ctx.fillStyle = '#f4a300';
  const wingOffset = Math.sin(Date.now()/120) * 3;
  ctx.ellipse(-4, wingOffset, 8, 5, 0, 0, Math.PI*2);
  ctx.fill(); ctx.stroke();
  // eye
  ctx.beginPath();
  ctx.fillStyle = '#fff';
  ctx.arc(6, -4, 4, 0, Math.PI*2); ctx.fill(); ctx.stroke();
  ctx.beginPath();
  ctx.fillStyle = '#000';
  ctx.arc(6, -4, 2, 0, Math.PI*2); ctx.fill();
  // beak
  ctx.beginPath();
  ctx.fillStyle = '#ff9800';
  ctx.moveTo(12,-2); ctx.lineTo(18,0); ctx.lineTo(12,2); ctx.closePath();
  ctx.fill(); ctx.stroke();
  ctx.restore();
}

// Overlay UI (for menu & game over)
const overlay = document.getElementById('overlay');
const overlayBox = document.getElementById('overlayBox');
function showOverlay(isGameOver=false){
  overlay.style.display = 'flex';
  overlayBox.innerHTML = isGameOver ? 
    `<div style="font-size:26px;font-weight:600;margin-bottom:8px">Game Over</div>
     <div style="margin-bottom:6px">Score: ${score} &nbsp;&nbsp; Best: ${best}</div>
     <div style="font-size:13px;color:#fff">Tap để chơi lại</div>` :
    `<div style="font-size:22px;font-weight:600;margin-bottom:8px">Flappy Bird</div>
     <div style="margin-bottom:6px">Best: ${best}</div>
     <div style="font-size:13px;color:#fff">Tap/Click/Space để bắt đầu</div>`;
}
function hideOverlay(){ overlay.style.display = 'none'; }

// Main loop
function frame(ts){
  if (!lastTime) lastTime = ts;
  // dt in seconds, clamped to avoid huge jumps (e.g., on resume)
  const dt = Math.min((ts - lastTime) / 1000, 0.05);
  lastTime = ts;
  update(dt);
  draw();
  requestAnimationFrame(frame);
}

// Init
reset();
requestAnimationFrame(frame);

// Ensure canvas sizing reacts immediately (mobile orientation)
window.addEventListener('orientationchange', () => setTimeout(resizeCanvas, 200));

// Accessibility: allow screen readers to skip
const sr = document.createElement('div'); sr.className='sr-only';
sr.textContent = 'Flappy Bird game. Tap screen to flap.';
document.body.appendChild(sr);
</script>
</body>
</html>
